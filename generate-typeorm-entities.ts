import { promises as fs } from 'node:fs';
import * as path from 'node:path';
import { getDMMF } from '@prisma/internals';
import type { DMMF } from '@prisma/generator-helper';
import { camelCase, kebabCase, pascalCase, snakeCase } from 'change-case';

const PROJECT_ROOT = path.resolve(__dirname, '.');
const SCHEMA_PATH = path.join(PROJECT_ROOT, 'schema.prisma');
const OUTPUT_ROOT = path.join(PROJECT_ROOT, 'src/database/prisma');
const ENTITIES_DIR = path.join(OUTPUT_ROOT, 'entities');
const ENUMS_FILE = path.join(OUTPUT_ROOT, 'prisma.enums.ts');
const HELPER_FILE = path.join(PROJECT_ROOT, 'src/utils/relational-entity-helper.ts');
const HEADER = `// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by generate-typeorm-entities.ts`;

type RelationSide = {
  modelName: string;
  field: DMMF.Field;
};

type RelationMap = Map<string, RelationSide[]>;

type RawValue = {
  raw: string;
};

type PrimitiveOption = string | number | boolean | RawValue;
type OptionValue = PrimitiveOption | PrimitiveOption[] | Record<string, PrimitiveOption | PrimitiveOption[]>;

interface ScalarRenderResult {
  lines: string[];
  typeormImports: Set<string>;
  enumImports: Set<string>;
}

interface RelationRenderResult {
  lines: string[];
  typeormImports: Set<string>;
  entityDependencies: Set<string>;
}

const raw = (value: string): RawValue => ({ raw: value });

function relativeFromEntities(target: string): string {
  const relPath = path.relative(ENTITIES_DIR, target).replace(/\\/g, '/').replace(/\.ts$/, '');
  return relPath.startsWith('.') ? relPath : `./${relPath}`;
}

const HELPER_IMPORT_PATH = relativeFromEntities(HELPER_FILE);
const ENUM_IMPORT_PATH = relativeFromEntities(ENUMS_FILE);

async function main() {
  const datamodel = await fs.readFile(SCHEMA_PATH, 'utf8');
  const dmmf = await getDMMF({ datamodel });

  await fs.rm(OUTPUT_ROOT, { recursive: true, force: true });
  await fs.mkdir(ENTITIES_DIR, { recursive: true });

  await generateEnums(dmmf.datamodel.enums);

  const relationMap = buildRelationMap(dmmf.datamodel.models);

  for (const model of dmmf.datamodel.models) {
    const filePath = path.join(ENTITIES_DIR, `${kebabCase(model.name)}.entity.ts`);
    const content = renderEntity(model, relationMap);
    await fs.writeFile(filePath, content);
  }
}

async function generateEnums(enums: readonly DMMF.DatamodelEnum[]) {
  const lines: string[] = [HEADER, ''];
  for (const prismaEnum of enums) {
    lines.push(`export enum ${prismaEnum.name} {`);
    for (const value of prismaEnum.values) {
      lines.push(`  ${value.name} = '${value.name}',`);
    }
    lines.push('}', '');
  }
  await fs.mkdir(path.dirname(ENUMS_FILE), { recursive: true });
  await fs.writeFile(ENUMS_FILE, lines.join('\n'));
}

function buildRelationMap(models: readonly DMMF.Model[]): RelationMap {
  const map: RelationMap = new Map();
  for (const model of models) {
    for (const field of model.fields) {
      if (field.kind !== 'object') continue;
      const key = getRelationKey(model.name, field);
      const bucket = map.get(key) ?? [];
      bucket.push({ modelName: model.name, field });
      map.set(key, bucket);
    }
  }
  return map;
}

function getRelationKey(modelName: string, field: DMMF.Field) {
  if (field.relationName) {
    return field.relationName;
  }
  const parts = [modelName, field.type].sort();
  return parts.join('::');
}

function renderEntity(model: DMMF.Model, relationMap: RelationMap): string {
  const className = `${pascalCase(model.name)}Entity`;
  const tableName = model.dbName ?? snakeCase(model.name);
  const schemaName = model.schema;
  const typeormImports = new Set<string>(['Entity']);
  const enumImports = new Set<string>();
  const relationDependencies = new Set<string>();
  const propertyLines: string[] = [];

  const classDecorators: string[] = [];
  const entityOptions: string[] = [`name: '${tableName}'`];
  if (schemaName) {
    entityOptions.push(`schema: '${schemaName}'`);
  }
  classDecorators.push(`@Entity({ ${entityOptions.join(', ')} })`);

  const uniqueIndexes = model.uniqueIndexes ?? [];
  for (const unique of uniqueIndexes) {
    if (!unique || unique.fields.length <= 1) continue;
    const indexName = unique.name ?? `uq_${tableName}_${unique.fields.join('_')}`;
    const props = unique.fields.map((fieldName) => `'${camelCase(fieldName)}'`).join(', ');
    classDecorators.push(`@Index('${indexName}', [${props}], { unique: true })`);
    typeormImports.add('Index');
  }

  for (const field of model.fields) {
    if (field.kind === 'object') {
      const relationRender = renderRelationField(model, field, relationMap);
      if (!relationRender) continue;
      relationRender.typeormImports.forEach((imp) => typeormImports.add(imp));
      relationRender.entityDependencies.forEach((dep) => relationDependencies.add(dep));
      propertyLines.push(...relationRender.lines, '');
      continue;
    }

      const scalarRender = renderScalarField(model, field);
    scalarRender.typeormImports.forEach((imp) => typeormImports.add(imp));
    scalarRender.enumImports.forEach((name) => enumImports.add(name));
    propertyLines.push(...scalarRender.lines, '');
  }

  if (propertyLines.length && propertyLines[propertyLines.length - 1] === '') {
    propertyLines.pop();
  }

  const importLines = buildImportLines(typeormImports, relationDependencies, enumImports);
  const classBody = ['export class ' + className + ' extends EntityRelationalHelper {', ...propertyLines.map((line) => (line ? `  ${line}` : '')), '}'];

  return [HEADER, '', ...importLines, '', ...classDecorators, ...classBody, ''].join('\n');
}

function buildImportLines(typeormImports: Set<string>, relationDependencies: Set<string>, enumImports: Set<string>): string[] {
  const lines: string[] = [];
  const sortedTypeormImports = Array.from(typeormImports).sort();
  lines.push(`import { ${sortedTypeormImports.join(', ')} } from 'typeorm';`);
  lines.push(`import { EntityRelationalHelper } from '${HELPER_IMPORT_PATH}';`);

  const relationImports = Array.from(relationDependencies)
    .filter((dep) => !!dep)
    .map((dep) => ({
      className: `${pascalCase(dep)}Entity`,
      path: `./${kebabCase(dep)}.entity`,
    }))
    .sort((a, b) => a.className.localeCompare(b.className));

  for (const rel of relationImports) {
    lines.push(`import { ${rel.className} } from '${rel.path}';`);
  }

  if (enumImports.size) {
    const sorted = Array.from(enumImports).sort();
    lines.push(`import { ${sorted.join(', ')} } from '${ENUM_IMPORT_PATH}';`);
  }

  return lines;
}

function renderScalarField(model: DMMF.Model, field: DMMF.Field): ScalarRenderResult {
  const typeormImports = new Set<string>();
  const enumImports = new Set<string>();
  const lines: string[] = [];
  const propertyName = camelCase(field.name);
  const propertyType = getTsType(field);
  const columnType = getColumnType(field);
  const isCompositePrimary = Boolean(model.primaryKey?.fields?.includes(field.name));
  const decoratorDetails = getDecoratorDetails(field, columnType, isCompositePrimary);

  if (decoratorDetails.decorator === 'PrimaryGeneratedColumn') {
    typeormImports.add('PrimaryGeneratedColumn');
  } else if (decoratorDetails.decorator === 'PrimaryColumn') {
    typeormImports.add('PrimaryColumn');
  } else {
    typeormImports.add('Column');
  }

  if (field.isUnique && decoratorDetails.decorator === 'Column') {
    const table = tableNameFor(model);
    const indexName = `uq_${table}_${field.name}`;
    lines.push(`@Index('${indexName}', { unique: true })`);
    typeormImports.add('Index');
  }

  const applyColumnOptions = decoratorDetails.decorator !== 'PrimaryGeneratedColumn';

  if (field.kind === 'enum' && applyColumnOptions) {
    enumImports.add(field.type);
    decoratorDetails.options.type = 'enum';
    decoratorDetails.options.enum = raw(field.type);
    decoratorDetails.options.enumName = `${tableNameFor(model)}_${field.name}_enum`;
  }

  if (applyColumnOptions) {
    decoratorDetails.options.name = field.name;
    decoratorDetails.options.nullable = !field.isRequired;
    decoratorDetails.options.type = decoratorDetails.options.type ?? columnType;
    if (field.isList) {
      decoratorDetails.options.array = true;
    }
  }

  const serializedOptions = applyColumnOptions ? serializeOptions(decoratorDetails.options) : undefined;
  const hasOptions = Boolean(serializedOptions && serializedOptions !== '{}');

  const decoratorArgs = decoratorDetails.decorator === 'PrimaryGeneratedColumn'
    ? [decoratorDetails.strategy ? `'${decoratorDetails.strategy}'` : undefined, hasOptions ? serializedOptions : undefined].filter(Boolean)
    : [serializedOptions ?? '{}'];

  lines.push(`@${decoratorDetails.decorator}(${decoratorArgs.join(', ')})`);
  lines.push(`${propertyName}${field.isRequired ? '' : '?'}: ${propertyType};`);

  return { lines, typeormImports, enumImports };
}

function renderRelationField(model: DMMF.Model, field: DMMF.Field, relationMap: RelationMap): RelationRenderResult | null {
  const counterpart = findCounterpart(model, field, relationMap);
  const targetModel = field.type;
  const targetEntity = `${pascalCase(targetModel)}Entity`;
  const propertyName = camelCase(field.name);
  const typeormImports = new Set<string>();
  const entityDependencies = new Set<string>();
  if (targetModel !== model.name) {
    entityDependencies.add(targetModel);
  }
  const lines: string[] = [];
  const relationOptions = buildRelationOptions(field);
  const optionsString = relationOptions ? `, ${relationOptions}` : '';
  const inverse = counterpart ? camelCase(counterpart.field.name) : undefined;
  const alias = camelCase(targetModel);

  if (field.isList) {
    if (counterpart?.field.isList) {
      typeormImports.add('ManyToMany');
      lines.push(`@ManyToMany(() => ${targetEntity}${inverse ? `, (${alias}) => ${alias}.${inverse}` : ''}${optionsString})`);
      typeormImports.add('JoinTable');
      lines.push('@JoinTable()');
      lines.push(`${propertyName}: ${targetEntity}[];`);
      return { lines, typeormImports, entityDependencies };
    }

    typeormImports.add('OneToMany');
    lines.push(`@OneToMany(() => ${targetEntity}${inverse ? `, (${alias}) => ${alias}.${inverse}` : ''}${optionsString})`);
    lines.push(`${propertyName}: ${targetEntity}[];`);
    return { lines, typeormImports, entityDependencies };
  }

  const isManyToOne = Boolean(counterpart?.field.isList);
  if (isManyToOne) {
    typeormImports.add('ManyToOne');
    lines.push(`@ManyToOne(() => ${targetEntity}${inverse ? `, (${alias}) => ${alias}.${inverse}` : ''}${optionsString})`);
  } else {
    typeormImports.add('OneToOne');
    lines.push(`@OneToOne(() => ${targetEntity}${inverse ? `, (${alias}) => ${alias}.${inverse}` : ''}${optionsString})`);
  }

  if (field.relationFromFields?.length) {
    const joinColumns = field.relationFromFields.map((fromField, index) => {
      const refField = field.relationToFields?.[index] ?? 'id';
      return `{ name: '${fromField}', referencedColumnName: '${camelCase(refField)}' }`;
    });
    if (joinColumns.length === 1) {
      typeormImports.add('JoinColumn');
      lines.push(`@JoinColumn(${joinColumns[0]})`);
    } else if (joinColumns.length > 1) {
      typeormImports.add('JoinColumns');
      lines.push('@JoinColumns([');
      for (const join of joinColumns) {
        lines.push(`  ${join},`);
      }
      lines.push('])');
    }
  }

  const optional = !field.isRequired;
  lines.push(`${propertyName}${optional ? '?' : ''}: ${targetEntity}${optional ? ' | null' : ''};`);

  return { lines, typeormImports, entityDependencies };
}

function getDecoratorDetails(field: DMMF.Field, columnType: string, isCompositePrimary: boolean) {
  if (field.isId && field.hasDefaultValue) {
    const defaultVal = field.default as Record<string, unknown> | undefined;
    if (defaultVal && typeof defaultVal === 'object' && 'name' in defaultVal) {
      const defaultName = String(defaultVal.name);
      if (defaultName === 'dbgenerated' || defaultName === 'uuid' || defaultName === 'cuid') {
        return { decorator: 'PrimaryGeneratedColumn', strategy: 'uuid', options: {} as Record<string, OptionValue> };
      }
      if (defaultName === 'autoincrement') {
        return { decorator: 'PrimaryGeneratedColumn', strategy: 'increment', options: {} as Record<string, OptionValue> };
      }
    }
  }

  if (field.isId || isCompositePrimary) {
    return { decorator: 'PrimaryColumn', options: { type: columnType, name: field.name } as Record<string, OptionValue> };
  }

  return { decorator: 'Column', options: { type: columnType, name: field.name } as Record<string, OptionValue> };
}

function getTsType(field: DMMF.Field): string {
  let baseType: string;
  if (field.kind === 'enum') {
    baseType = field.type;
  } else {
    switch (field.type) {
      case 'Int':
      case 'Float':
        baseType = 'number';
        break;
      case 'BigInt':
      case 'Decimal':
        baseType = 'string';
        break;
      case 'DateTime':
      case 'Date':
        baseType = 'Date';
        break;
      case 'Boolean':
        baseType = 'boolean';
        break;
      case 'Json':
        baseType = 'Record<string, unknown>';
        break;
      case 'Bytes':
        baseType = 'Buffer';
        break;
      default:
        baseType = 'string';
    }
  }

  if (field.isList) {
    return `${baseType}[]`;
  }

  if (!field.isRequired) {
    return `${baseType} | null`;
  }

  return baseType;
}

function getColumnType(field: DMMF.Field): string {
  if (field.nativeType && field.nativeType.length) {
    const [native] = field.nativeType;
    switch (native) {
      case 'Uuid':
        return 'uuid';
      case 'Timestamptz':
        return 'timestamptz';
      case 'Timestamp':
        return 'timestamp';
      case 'Date':
        return 'date';
      case 'Json':
        return 'jsonb';
      case 'Text':
        return 'text';
      case 'VarChar':
      case 'String':
        return 'varchar';
      case 'Char':
        return 'char';
      case 'BigInt':
        return 'bigint';
      case 'Decimal':
        return 'numeric';
      default:
        break;
    }
  }

  switch (field.type) {
    case 'Int':
      return 'integer';
    case 'Float':
      return 'double precision';
    case 'Decimal':
      return 'numeric';
    case 'BigInt':
      return 'bigint';
    case 'Boolean':
      return 'boolean';
    case 'DateTime':
      return 'timestamptz';
    case 'Date':
      return 'date';
    case 'Json':
      return 'jsonb';
    case 'Bytes':
      return 'bytea';
    default:
      return 'varchar';
  }
}

function serializeOptions(options: Record<string, OptionValue>): string {
  const entries = Object.entries(options).filter(([, value]) => value !== undefined);
  if (!entries.length) {
    return '{}';
  }
  const inner = entries
    .map(([key, value]) => `  ${key}: ${serializeValue(value)}`)
    .join(',\n');
  return `{\n${inner}\n}`;
}

function serializeValue(value: OptionValue): string {
  if (value && typeof value === 'object' && 'raw' in value) {
    return (value as RawValue).raw;
  }
  if (Array.isArray(value)) {
    return `[${value.map((item) => serializeValue(item)).join(', ')}]`;
  }
  if (typeof value === 'object' && value !== null) {
    const entries = Object.entries(value).map(([key, val]) => `${key}: ${serializeValue(val)}`);
    return `{ ${entries.join(', ')} }`;
  }
  if (typeof value === 'string') {
    return `'${value.replace(/'/g, "\\'")}'`;
  }
  return String(value);
}

function tableNameFor(model: DMMF.Model): string {
  return model.dbName ?? snakeCase(model.name);
}

function buildRelationOptions(field: DMMF.Field): string | null {
  const options: Record<string, OptionValue> = {};
  if (field.relationOnDelete) {
    options.onDelete = mapRelationAction(field.relationOnDelete);
  }
  if (field.relationOnUpdate) {
    options.onUpdate = mapRelationAction(field.relationOnUpdate);
  }
  return Object.keys(options).length ? serializeOptions(options) : null;
}

function mapRelationAction(action?: string) {
  switch (action) {
    case 'Cascade':
      return 'CASCADE';
    case 'SetNull':
      return 'SET NULL';
    case 'Restrict':
      return 'RESTRICT';
    default:
      return 'NO ACTION';
  }
}

function findCounterpart(model: DMMF.Model, field: DMMF.Field, relationMap: RelationMap) {
  const key = getRelationKey(model.name, field);
  const sides = relationMap.get(key) ?? [];
  return sides.find((side) => !(side.modelName === model.name && side.field.name === field.name));
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
