import { promises as fs } from 'node:fs';
import * as path from 'node:path';
import { getDMMF } from '@prisma/internals';
import type { DMMF } from '@prisma/generator-helper';
import { camelCase, kebabCase, pascalCase } from 'change-case';
import pluralizeLib = require('pluralize');

const PROJECT_ROOT = path.resolve(__dirname, '.');
const SCHEMA_PATH = path.join(PROJECT_ROOT, 'schema.prisma');
const CONFIG_PATH = path.join(__dirname, 'prisma-hexagonal.config.json');
const OUTPUT_ROOT = path.join(PROJECT_ROOT, 'src/prisma-generated');
const ENTITY_ROOT = path.join(PROJECT_ROOT, 'src/database/prisma/entities');
const SHARED_ROOT = path.join(PROJECT_ROOT, 'libs/shared/src');
const SHARED_ENUMS_ROOT = path.join(SHARED_ROOT, 'lib/prisma-enums');
const SHARED_ENUMS_INDEX_FILE = path.join(SHARED_ENUMS_ROOT, 'index.ts');
const SHARED_INDEX_FILE = path.join(SHARED_ROOT, 'index.ts');
const ENUM_IMPORT_PATH = '@libs/shared';
const UTILS_ROOT = path.join(PROJECT_ROOT, 'src/utils');
const DEEP_PARTIAL_PATH = path.join(UTILS_ROOT, 'types/deep-partial.type.ts');
const NULLABLE_PATH = path.join(UTILS_ROOT, 'types/nullable.type.ts');
const PAGINATION_OPTIONS_PATH = path.join(UTILS_ROOT, 'types/pagination-options.ts');
const HEADER = `// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by tools/scripts/generate-hexagonal-resources.ts`;

interface HexModuleConfig {
  model: string;
  domainName?: string;
  slug?: string;
  outputRoot?: string;
}

interface HexConfig {
  modules: HexModuleConfig[];
}

interface ModuleContext {
  config: HexModuleConfig;
  model: DMMF.Model;
  scalarFields: DMMF.Field[];
  relationFields: DMMF.Field[];
  relations: RelationMetadata[];
  idField: DMMF.Field | null;
  className: string;
  pluralClassName: string;
  fileBaseName: string;
  slug: string;
  moduleDir: string;
  domainDir: string;
  dtoDir: string;
  infrastructureDir: string;
  persistenceDir: string;
  relationalDir: string;
  relationalEntitiesDir: string;
  relationalMappersDir: string;
  relationalRepositoriesDir: string;
  domainFile: string;
  dtoFiles: {
    entity: string;
    create: string;
    update: string;
    query: string;
  };
  repositoryPortFile: string;
  relationalModuleFile: string;
  relationalRepositoryFile: string;
  relationalEntityFile: string;
  mapperFile: string;
}

interface RelationMetadata {
  field: DMMF.Field;
  propertyName: string;
  targetModel: string;
  targetContext?: ModuleContext;
}

interface ValidationRenderResult {
  decorators: string[];
  validatorImports: Set<string>;
  needsTransformer: boolean;
  enumImports: Set<string>;
}

interface DtoPropertyRenderResult {
  lines: string[];
  usesOptionalDecorator: boolean;
  validatorImports: Set<string>;
  needsTransformer: boolean;
  enumImports: Set<string>;
}

const READ_ONLY_FIELDS = new Set(['created_at', 'createdAt', 'updated_at', 'updatedAt', 'deleted_at', 'deletedAt']);

async function main() {
  const datamodel = await fs.readFile(SCHEMA_PATH, 'utf8');
  const dmmf = await getDMMF({ datamodel });
  const config = await loadConfig();

  const moduleContexts: ModuleContext[] = [];
  for (const moduleConfig of config.modules) {
    const model = dmmf.datamodel.models.find((item) => item.name === moduleConfig.model);
    if (!model) {
      console.warn(`[hex-generator] Model "${moduleConfig.model}" not found in Prisma schema. Skipping.`);
      continue;
    }
    moduleContexts.push(buildModuleContext(moduleConfig, model));
  }

  const contextByModelName = new Map(moduleContexts.map((ctx) => [ctx.model.name, ctx] as const));
  attachRelationMetadata(moduleContexts, contextByModelName);
  await generateSharedEnums(dmmf.datamodel.enums);

  for (const moduleContext of moduleContexts) {
    await ensureDirectories([
      moduleContext.domainDir,
      moduleContext.dtoDir,
      moduleContext.infrastructureDir,
      moduleContext.persistenceDir,
      moduleContext.relationalDir,
      moduleContext.relationalEntitiesDir,
      moduleContext.relationalMappersDir,
      moduleContext.relationalRepositoriesDir,
    ]);

    const domainContent = renderDomain(moduleContext);
    const entityDtoContent = renderEntityDto(moduleContext);
    const createDtoContent = renderCreateDto(moduleContext);
    const updateDtoContent = renderUpdateDto(moduleContext);
    const queryDtoContent = renderQueryDto(moduleContext);
    const repositoryPortContent = renderRepositoryPort(moduleContext);
    const relationalEntityBridge = renderRelationalEntityBridge(moduleContext);
    const mapperContent = renderMapper(moduleContext);
    const relationalRepositoryContent = renderRelationalRepository(moduleContext);
    const relationalModuleContent = renderRelationalPersistenceModule(moduleContext);

    await Promise.all([
      fs.writeFile(moduleContext.domainFile, domainContent),
      fs.writeFile(moduleContext.dtoFiles.entity, entityDtoContent),
      fs.writeFile(moduleContext.dtoFiles.create, createDtoContent),
      fs.writeFile(moduleContext.dtoFiles.update, updateDtoContent),
      fs.writeFile(moduleContext.dtoFiles.query, queryDtoContent),
      fs.writeFile(moduleContext.repositoryPortFile, repositoryPortContent),
      fs.writeFile(moduleContext.relationalEntityFile, relationalEntityBridge),
      fs.writeFile(moduleContext.mapperFile, mapperContent),
      fs.writeFile(moduleContext.relationalRepositoryFile, relationalRepositoryContent),
      fs.writeFile(moduleContext.relationalModuleFile, relationalModuleContent),
    ]);
  }
}

async function loadConfig(): Promise<HexConfig> {
  const raw = await fs.readFile(CONFIG_PATH, 'utf8');
  const config = JSON.parse(raw) as HexConfig;
  if (!config.modules?.length) {
    throw new Error('No modules defined in prisma-hexagonal.config.json');
  }
  return config;
}

function buildModuleContext(config: HexModuleConfig, model: DMMF.Model): ModuleContext {
  const className = config.domainName ?? singularize(pascalCase(model.name));
  const fileBaseName = kebabCase(className);
  const slug = config.slug ?? kebabCase(model.name);
  const moduleDir = config.outputRoot
    ? path.join(PROJECT_ROOT, config.outputRoot)
    : path.join(OUTPUT_ROOT, slug);
  const domainDir = path.join(moduleDir, 'domain');
  const dtoDir = path.join(moduleDir, 'dto');
  const infrastructureDir = path.join(moduleDir, 'infrastructure');
  const persistenceDir = path.join(infrastructureDir, 'persistence');
  const relationalDir = path.join(persistenceDir, 'relational');
  const relationalEntitiesDir = path.join(relationalDir, 'entities');
  const relationalMappersDir = path.join(relationalDir, 'mappers');
  const relationalRepositoriesDir = path.join(relationalDir, 'repositories');
  const scalarFields = getScalarFields(model);
  const relationFields = getRelationFields(model);
  const primaryKeyFieldName = model.primaryKey?.fields?.[0];
  const idField =
    model.fields.find((field) => field.isId) ??
    (primaryKeyFieldName ? model.fields.find((field) => field.name === primaryKeyFieldName) ?? null : null);

  return {
    config,
    model,
    scalarFields,
    relationFields,
    relations: [],
    idField,
    className,
    pluralClassName: pluralize(className),
    fileBaseName,
    slug,
    moduleDir,
    domainDir,
    dtoDir,
    infrastructureDir,
    persistenceDir,
    relationalDir,
    relationalEntitiesDir,
    relationalMappersDir,
    relationalRepositoriesDir,
    domainFile: path.join(domainDir, `${fileBaseName}.domain.ts`),
    dtoFiles: {
      entity: path.join(dtoDir, `${fileBaseName}.dto.ts`),
      create: path.join(dtoDir, `create-${fileBaseName}.dto.ts`),
      update: path.join(dtoDir, `update-${fileBaseName}.dto.ts`),
      query: path.join(dtoDir, `query-${fileBaseName}.dto.ts`),
    },
    repositoryPortFile: path.join(persistenceDir, `${fileBaseName}.repository.ts`),
    relationalModuleFile: path.join(relationalDir, 'relational-persistence.module.ts'),
    relationalRepositoryFile: path.join(relationalRepositoriesDir, `${fileBaseName}.repository.ts`),
    relationalEntityFile: path.join(relationalEntitiesDir, `${fileBaseName}.entity.ts`),
    mapperFile: path.join(relationalMappersDir, `${fileBaseName}.mapper.ts`),
  };
}

async function ensureDirectories(pathsToEnsure: string[]) {
  await Promise.all(pathsToEnsure.map((dir) => fs.mkdir(dir, { recursive: true })));
}

async function generateSharedEnums(enums: readonly DMMF.DatamodelEnum[]) {
  if (!enums.length) {
    return;
  }

  await fs.mkdir(SHARED_ENUMS_ROOT, { recursive: true });
  const exportStatements: string[] = [];

  for (const enumDef of enums) {
    const fileName = `${kebabCase(enumDef.name)}.enum.ts`;
    const filePath = path.join(SHARED_ENUMS_ROOT, fileName);
    const enumLines = [
      HEADER,
      '',
      `export enum ${enumDef.name} {`,
      ...enumDef.values.map((value) => `  ${value.name} = '${(value.dbName ?? value.name).replace(/'/g, "\\'")}',`),
      '}',
      '',
    ];
    await fs.writeFile(filePath, enumLines.join('\n'));
    exportStatements.push(`export * from './${fileName.replace(/\.ts$/, '')}';`);
  }

  exportStatements.sort((a, b) => a.localeCompare(b));
  await fs.writeFile(SHARED_ENUMS_INDEX_FILE, [HEADER, '', ...exportStatements, ''].join('\n'));
  await ensureSharedIndexExportsPrismaEnums();
}

async function ensureSharedIndexExportsPrismaEnums() {
  const exportLine = "export * from './lib/prisma-enums';";
  let content = '';
  try {
    content = await fs.readFile(SHARED_INDEX_FILE, 'utf8');
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
      throw error;
    }
  }

  if (content.includes(exportLine)) {
    if (!content.endsWith('\n')) {
      await fs.writeFile(SHARED_INDEX_FILE, `${content}\n`);
    }
    return;
  }

  const nextContent = content ? `${content.trimEnd()}\n${exportLine}\n` : `${exportLine}\n`;
  await fs.writeFile(SHARED_INDEX_FILE, nextContent);
}

function renderDomain(context: ModuleContext): string {
  const usesOptional =
    context.scalarFields.some((field) => !field.isRequired) ||
    context.relations.some((relation) => !relation.field.isRequired);
  const enumImports = new Set<string>();
  const relationImports = new Map<string, string>();
  const bodyLines: string[] = [];

  context.scalarFields.forEach((field, index) => {
    const typeInfo = getTypeInfo(field);
    if (typeInfo.enumType) {
      enumImports.add(typeInfo.enumType);
    }
    if (index > 0) {
      bodyLines.push('');
    }
    const propertyLines = renderDomainProperty(field, typeInfo);
    propertyLines.forEach((line) => bodyLines.push(`  ${line}`));
  });

  context.relations.forEach((relation) => {
    if (!relation.targetContext) {
      throw new Error(
        `[hex-generator] Missing module context for relation ${context.model.name}.${relation.field.name} -> ${relation.targetModel}`,
      );
    }
    if (relation.targetContext !== context) {
      relationImports.set(
        relation.targetContext.className,
        relativeImport(context.domainFile, relation.targetContext.domainFile),
      );
    }
    if (bodyLines.length) {
      bodyLines.push('');
    }
    const relationLines = renderRelationProperty(relation);
    relationLines.forEach((line) => bodyLines.push(`  ${line}`));
  });

  const importLines = [`import { ApiProperty${usesOptional ? ', ApiPropertyOptional' : ''} } from '@nestjs/swagger';`];
  if (enumImports.size) {
    importLines.push(`import { ${Array.from(enumImports).sort().join(', ')} } from '${ENUM_IMPORT_PATH}';`);
  }
  Array.from(relationImports.entries())
    .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))
    .forEach(([importName, importPath]) => {
      importLines.push(`import { ${importName} } from '${importPath}';`);
    });

  return [HEADER, '', ...importLines, '', `export class ${context.className} {`, ...bodyLines, '}', ''].join('\n');
}

function renderEntityDto(context: ModuleContext): string {
  const idField = ensureIdField(context);
  const identifierProperty = camelCase(idField.name);
  const typeInfo = getTypeInfo(idField);
  const validation = renderValidationDecorators(idField, false);
  const validatorImports = new Set<string>(['IsNotEmpty']);
  validation.validatorImports.forEach((item) => validatorImports.add(item));
  const enumImports = new Set<string>();
  if (typeInfo.enumType) {
    enumImports.add(typeInfo.enumType);
  }
  validation.enumImports.forEach((item) => enumImports.add(item));

  const lines: string[] = [HEADER, '', "import { ApiProperty } from '@nestjs/swagger';"];
  if (validatorImports.size) {
    lines.push(`import { ${Array.from(validatorImports).sort().join(', ')} } from 'class-validator';`);
  }
  if (validation.needsTransformer) {
    lines.push("import { Type } from 'class-transformer';");
  }
  if (enumImports.size) {
    lines.push(`import { ${Array.from(enumImports).sort().join(', ')} } from '${ENUM_IMPORT_PATH}';`);
  }

  lines.push('', `export class ${context.className}Dto {`);
  lines.push('  @ApiProperty()');
  validation.decorators.forEach((decorator) => {
    lines.push(`  ${decorator}`);
  });
  lines.push('  @IsNotEmpty()');
  lines.push(`  ${identifierProperty}!: ${buildTsType(typeInfo)};`);
  lines.push('}', '');

  return lines.join('\n');
}

function renderCreateDto(context: ModuleContext): string {
  const createFields = context.scalarFields.filter((field) => isWritableField(field));
  const blocks = createFields.map((field) => renderDtoProperty(field, determineCreateOptional(field)));

  const swaggerImports = new Set<string>();
  if (blocks.some((block) => !block.usesOptionalDecorator)) {
    swaggerImports.add('ApiProperty');
  }
  if (blocks.some((block) => block.usesOptionalDecorator)) {
    swaggerImports.add('ApiPropertyOptional');
  }
  if (!swaggerImports.size) {
    swaggerImports.add('ApiProperty');
  }

  const validatorImports = new Set<string>();
  let needsTransformer = false;
  const enumImports = new Set<string>();

  blocks.forEach((block) => {
    block.validatorImports.forEach((item) => validatorImports.add(item));
    if (block.needsTransformer) {
      needsTransformer = true;
    }
    block.enumImports.forEach((item) => enumImports.add(item));
  });

  const lines: string[] = [HEADER, '', `import { ${Array.from(swaggerImports).sort().join(', ')} } from '@nestjs/swagger';`];

  if (validatorImports.size) {
    lines.push(`import { ${Array.from(validatorImports).sort().join(', ')} } from 'class-validator';`);
  }

  if (needsTransformer) {
    lines.push("import { Type } from 'class-transformer';");
  }

  if (enumImports.size) {
    lines.push(`import { ${Array.from(enumImports).sort().join(', ')} } from '${ENUM_IMPORT_PATH}';`);
  }

  lines.push('', `export class Create${context.className}Dto {`);

  if (!blocks.length) {
    lines.push('  // Intentionally left blank');
  } else {
    blocks.forEach((block, index) => {
      if (index > 0) {
        lines.push('');
      }
      block.lines.forEach((line) => lines.push(`  ${line}`));
    });
  }

  lines.push('}', '');
  return lines.join('\n');
}

function renderUpdateDto(context: ModuleContext): string {
  return [
    HEADER,
    '',
    "import { PartialType } from '@nestjs/swagger';",
    `import { Create${context.className}Dto } from '${relativeImport(context.dtoFiles.update, context.dtoFiles.create)}';`,
    '',
    `export class Update${context.className}Dto extends PartialType(Create${context.className}Dto) {}`,
    '',
  ].join('\n');
}

function renderQueryDto(context: ModuleContext): string {
  const filterBlocks = context.scalarFields.map((field) => renderDtoProperty(field, true));

  const swaggerImports = new Set(['ApiProperty', 'ApiPropertyOptional']);
  const validatorImports = new Set<string>(['IsOptional']);
  const enumImports = new Set<string>();

  filterBlocks.forEach((block) => {
    block.validatorImports.forEach((item) => validatorImports.add(item));
    block.enumImports.forEach((item) => enumImports.add(item));
  });

  validatorImports.add('IsNumber');
  validatorImports.add('IsString');

  const lines: string[] = [
    HEADER,
    '',
    `import { ${Array.from(swaggerImports).sort().join(', ')} } from '@nestjs/swagger';`,
    "import { Type } from 'class-transformer';",
    `import { ${Array.from(validatorImports).sort().join(', ')} } from 'class-validator';`,
    `import { ${context.className} } from '${relativeImport(context.dtoFiles.query, context.domainFile)}';`,
  ];

  if (enumImports.size) {
    lines.push(`import { ${Array.from(enumImports).sort().join(', ')} } from '${ENUM_IMPORT_PATH}';`);
  }

  lines.push('', `export class Filter${context.className}Dto {`);
  if (!filterBlocks.length) {
    lines.push('  // Intentionally left blank');
  } else {
    filterBlocks.forEach((block, index) => {
      if (index > 0) {
        lines.push('');
      }
      block.lines.forEach((line) => lines.push(`  ${line}`));
    });
  }
  lines.push('}', '');

  lines.push(`export class Sort${context.className}Dto {`);
  lines.push('  @ApiProperty()');
  lines.push('  @Type(() => String)');
  lines.push('  @IsString()');
  lines.push(`  orderBy!: keyof ${context.className};`);
  lines.push('');
  lines.push('  @ApiProperty()');
  lines.push('  @IsString()');
  lines.push("  order!: 'ASC' | 'DESC' | 'asc' | 'desc';");
  lines.push('}', '');

  lines.push(`export class Query${context.className}Dto {`);
  lines.push('  @ApiPropertyOptional()');
  lines.push('  @Type(() => Number)');
  lines.push('  @IsNumber()');
  lines.push('  @IsOptional()');
  lines.push('  page?: number;');
  lines.push('');
  lines.push('  @ApiPropertyOptional()');
  lines.push('  @Type(() => Number)');
  lines.push('  @IsNumber()');
  lines.push('  @IsOptional()');
  lines.push('  limit?: number;');
  lines.push('');
  lines.push(`  @ApiPropertyOptional({ type: () => Filter${context.className}Dto })`);
  lines.push('  @IsOptional()');
  lines.push(`  @Type(() => Filter${context.className}Dto)`);
  lines.push(`  filters?: Filter${context.className}Dto | null;`);
  lines.push('');
  lines.push(`  @ApiPropertyOptional({ type: () => [Sort${context.className}Dto] })`);
  lines.push('  @IsOptional()');
  lines.push(`  @Type(() => Sort${context.className}Dto)`);
  lines.push(`  sort?: Sort${context.className}Dto[] | null;`);
  lines.push('}', '');

  return lines.join('\n');
}

function renderRepositoryPort(context: ModuleContext): string {
  const filterDtoName = `Filter${context.className}Dto`;
  const sortDtoName = `Sort${context.className}Dto`;
  const repositoryName = `${context.className}Repository`;
  const createDataType = getCreateDataType(context);
  const identifierProperty = getIdentifierPropertyName(context);
  const identifierTypeRef = `${context.className}['${identifierProperty}']`;

  const lines: string[] = [
    HEADER,
    '',
    `import { ${context.className} } from '${relativeImport(context.repositoryPortFile, context.domainFile)}';`,
    `import { ${filterDtoName}, ${sortDtoName} } from '${relativeImport(context.repositoryPortFile, context.dtoFiles.query)}';`,
    `import { DeepPartial } from '${relativeImport(context.repositoryPortFile, DEEP_PARTIAL_PATH)}';`,
    `import { NullableType } from '${relativeImport(context.repositoryPortFile, NULLABLE_PATH)}';`,
    `import { IPaginationOptions } from '${relativeImport(context.repositoryPortFile, PAGINATION_OPTIONS_PATH)}';`,
    '',
    `export abstract class ${repositoryName} {`,
    `  abstract create(data: ${createDataType}): Promise<${context.className}>;`,
    '',
  ];

  lines.push('  abstract findManyWithPagination({');
  lines.push('    filterOptions,');
  lines.push('    sortOptions,');
  lines.push('    paginationOptions,');
  lines.push('  }: {');
  lines.push(`    filterOptions?: ${filterDtoName} | null;`);
  lines.push(`    sortOptions?: ${sortDtoName}[] | null;`);
  lines.push('    paginationOptions: IPaginationOptions;');
  lines.push(`  }): Promise<{ data: ${context.className}[]; total: number }>;`);
  lines.push('');
  lines.push(`  abstract findById(id: ${identifierTypeRef}): Promise<NullableType<${context.className}>>;`);
  lines.push(
    `  abstract update(id: ${identifierTypeRef}, payload: DeepPartial<${context.className}>): Promise<${context.className} | null>;`,
  );
  lines.push(`  abstract remove(id: ${identifierTypeRef}): Promise<void>;`);
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

function renderRelationalEntityBridge(context: ModuleContext): string {
  const prismaEntityName = `${pascalCase(context.model.name)}Entity`;
  const aliasName = getEntityAliasName(context);
  const entityImportPath = path.join(ENTITY_ROOT, `${kebabCase(context.model.name)}.entity.ts`);

  return [
    HEADER,
    '',
    `export { ${prismaEntityName} as ${aliasName} } from '${relativeImport(context.relationalEntityFile, entityImportPath)}';`,
    '',
  ].join('\n');
}

function renderMapper(context: ModuleContext): string {
  const entityName = getEntityAliasName(context);
  const relationMapperImports = new Map<string, string>();

  context.relations.forEach((relation) => {
    if (!relation.targetContext) {
      throw new Error(
        `[hex-generator] Missing module context for relation ${context.model.name}.${relation.field.name} -> ${relation.targetModel}`,
      );
    }
    if (relation.targetContext !== context) {
      relationMapperImports.set(
        `${relation.targetContext.className}Mapper`,
        relativeImport(context.mapperFile, relation.targetContext.mapperFile),
      );
    }
  });

  const lines: string[] = [
    HEADER,
    '',
    `import { ${context.className} } from '${relativeImport(context.mapperFile, context.domainFile)}';`,
    `import { ${entityName} } from '${relativeImport(context.mapperFile, context.relationalEntityFile)}';`,
  ];

  Array.from(relationMapperImports.entries())
    .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))
    .forEach(([importName, importPath]) => {
      lines.push(`import { ${importName} } from '${importPath}';`);
    });

  lines.push('', `export class ${context.className}Mapper {`);
  lines.push(`  static toDomain(entity: ${entityName}): ${context.className} {`);
  lines.push(`    const domain = new ${context.className}();`);

  context.scalarFields.forEach((field) => {
    const propertyName = camelCase(field.name);
    if (field.isRequired) {
      lines.push(`    domain.${propertyName} = entity.${propertyName};`);
    } else {
      lines.push(`    domain.${propertyName} = entity.${propertyName} ?? null;`);
    }
  });

  context.relations.forEach((relation) => {
    const assignment = buildRelationToDomainExpression(context, relation);
    lines.push(`    domain.${relation.propertyName} = ${assignment};`);
  });

  lines.push('    return domain;');
  lines.push('  }');
  lines.push('');
  lines.push(`  static toEntity(domain: ${context.className}): ${entityName} {`);
  lines.push(`    const entity = new ${entityName}();`);

  context.scalarFields.forEach((field) => {
    const propertyName = camelCase(field.name);
    if (field.isRequired) {
      lines.push(`    entity.${propertyName} = domain.${propertyName};`);
    } else {
      lines.push(`    entity.${propertyName} = domain.${propertyName} ?? null;`);
    }
  });

  context.relations.forEach((relation) => {
    const assignments = buildRelationToEntityAssignmentLines(context, relation);
    assignments.forEach((assignmentLine) => {
      lines.push(`    ${assignmentLine}`);
    });
  });

  lines.push('    return entity;');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

function renderRelationalRepository(context: ModuleContext): string {
  const repositoryClassName = `${context.pluralClassName}RelationalRepository`;
  const repositoryPortName = `${context.className}Repository`;
  const mapperName = `${context.className}Mapper`;
  const entityName = getEntityAliasName(context);
  const filterDtoName = `Filter${context.className}Dto`;
  const sortDtoName = `Sort${context.className}Dto`;
  const createDataType = getCreateDataType(context);
  const relationProps = context.relations.map((relation) => `'${relation.propertyName}'`).join(', ');
  const relationArrayLiteral = relationProps ? `[${relationProps}]` : '[]';
  const identifierProperty = getIdentifierPropertyName(context);
  const identifierTypeRef = `${context.className}['${identifierProperty}']`;

  const lines: string[] = [
    HEADER,
    '',
    "import { Injectable } from '@nestjs/common';",
    "import { InjectRepository } from '@nestjs/typeorm';",
  "import { FindOptionsOrder, FindOptionsOrderValue, FindOptionsWhere, Repository } from 'typeorm';",
    `import { DeepPartial } from '${relativeImport(context.relationalRepositoryFile, DEEP_PARTIAL_PATH)}';`,
    `import { NullableType } from '${relativeImport(context.relationalRepositoryFile, NULLABLE_PATH)}';`,
    `import { IPaginationOptions } from '${relativeImport(context.relationalRepositoryFile, PAGINATION_OPTIONS_PATH)}';`,
    `import { ${context.className} } from '${relativeImport(context.relationalRepositoryFile, context.domainFile)}';`,
    `import { ${repositoryPortName} } from '${relativeImport(context.relationalRepositoryFile, context.repositoryPortFile)}';`,
    `import { ${mapperName} } from '${relativeImport(context.relationalRepositoryFile, context.mapperFile)}';`,
    `import { ${entityName} } from '${relativeImport(context.relationalRepositoryFile, context.relationalEntityFile)}';`,
    `import { ${filterDtoName}, ${sortDtoName} } from '${relativeImport(context.relationalRepositoryFile, context.dtoFiles.query)}';`,
    '',
    '@Injectable()',
    `export class ${repositoryClassName} implements ${repositoryPortName} {`,
    '  constructor(',
    `    @InjectRepository(${entityName})`,
    `    private readonly repository: Repository<${entityName}>,`,
  '  ) {}',
  '',
  `  private readonly relations = ${relationArrayLiteral};`,
  '',
    `  async create(data: ${createDataType}): Promise<${context.className}> {`,
    `    const persistenceModel = ${mapperName}.toEntity(data as ${context.className});`,
    '    const entity = this.repository.create(persistenceModel);',
    '    const saved = await this.repository.save(entity);',
    `    return ${mapperName}.toDomain(saved);`,
    '  }',
    '',
  ];

  lines.push('  async findManyWithPagination({');
  lines.push('    filterOptions,');
  lines.push('    sortOptions,');
  lines.push('    paginationOptions,');
  lines.push('  }: {');
  lines.push(`    filterOptions?: ${filterDtoName} | null;`);
  lines.push(`    sortOptions?: ${sortDtoName}[] | null;`);
  lines.push('    paginationOptions: IPaginationOptions;');
  lines.push(`  }): Promise<{ data: ${context.className}[]; total: number }> {`);
  lines.push('    const page = paginationOptions?.page ?? 1;');
  lines.push('    const limit = paginationOptions?.limit ?? 10;');
  lines.push('    const where = this.buildWhere(filterOptions);');
  lines.push('    const order = this.buildOrder(sortOptions);');
  lines.push('    const [entities, total] = await this.repository.findAndCount({');
  lines.push('      where,');
  lines.push('      order,');
  lines.push('      relations: this.relations.length ? this.relations : undefined,');
  lines.push('      skip: (page - 1) * limit,');
  lines.push('      take: limit,');
  lines.push('    });');
  lines.push('    return {');
  lines.push(`      data: entities.map((entity) => ${mapperName}.toDomain(entity)),`);
  lines.push('      total,');
  lines.push('    };');
  lines.push('  }');
  lines.push('');

  lines.push(`  async findById(id: ${identifierTypeRef}): Promise<NullableType<${context.className}>> {`);
  lines.push(
    `    const entity = await this.repository.findOne({ where: { ${identifierProperty}: id } as FindOptionsWhere<${entityName}>, relations: this.relations.length ? this.relations : undefined });`,
  );
  lines.push(`    return entity ? ${mapperName}.toDomain(entity) : null;`);
  lines.push('  }');
  lines.push('');

  lines.push(`  async update(id: ${identifierTypeRef}, payload: DeepPartial<${context.className}>): Promise<${context.className} | null> {`);
  lines.push(
    `    const entity = await this.repository.findOne({ where: { ${identifierProperty}: id } as FindOptionsWhere<${entityName}>, relations: this.relations.length ? this.relations : undefined });`,
  );
  lines.push('    if (!entity) {');
  lines.push('      return null;');
  lines.push('    }');
  lines.push(`    const domain = ${mapperName}.toDomain(entity);`);
  lines.push(`    const merged = { ...domain, ...payload } as ${context.className};`);
  lines.push(`    const updated = this.repository.merge(entity, ${mapperName}.toEntity(merged));`);
  lines.push('    const saved = await this.repository.save(updated);');
  lines.push(`    return ${mapperName}.toDomain(saved);`);
  lines.push('  }');
  lines.push('');

  lines.push(`  async remove(id: ${identifierTypeRef}): Promise<void> {`);
  lines.push(`    await this.repository.delete({ ${identifierProperty}: id } as FindOptionsWhere<${entityName}>);`);
  lines.push('  }');
  lines.push('');

  lines.push(`  private buildWhere(filterOptions?: ${filterDtoName} | null): FindOptionsWhere<${entityName}> | undefined {`);
  lines.push('    if (!filterOptions) {');
  lines.push('      return undefined;');
  lines.push('    }');
  lines.push('    const where: Record<string, unknown> = {};');
  context.scalarFields.forEach((field) => {
    const propertyName = camelCase(field.name);
    lines.push(`    if (filterOptions.${propertyName} !== undefined) {`);
    lines.push(`      where.${propertyName} = filterOptions.${propertyName};`);
    lines.push('    }');
  });
  lines.push(`    return Object.keys(where).length ? (where as FindOptionsWhere<${entityName}>) : undefined;`);
  lines.push('  }');
  lines.push('');

  lines.push(`  private buildOrder(sortOptions?: ${sortDtoName}[] | null): FindOptionsOrder<${entityName}> | undefined {`);
  lines.push('    if (!sortOptions || !sortOptions.length) {');
  lines.push('      return undefined;');
  lines.push('    }');
  lines.push(`    const order: FindOptionsOrder<${entityName}> = {};`);
  lines.push('    const orderRecord = order as Record<string, FindOptionsOrderValue>;');
  lines.push('    sortOptions.forEach((sort) => {');
  lines.push("      const direction = sort.order?.toUpperCase() === 'DESC' ? 'DESC' : 'ASC';");
  lines.push('      orderRecord[sort.orderBy as string] = direction as FindOptionsOrderValue;');
  lines.push('    });');
  lines.push('    return order;');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

function renderRelationalPersistenceModule(context: ModuleContext): string {
  const repositoryPortName = `${context.className}Repository`;
  const repositoryAdapterName = `${context.pluralClassName}RelationalRepository`;
  const entityName = getEntityAliasName(context);
  const moduleClassName = `Relational${context.className}PersistenceModule`;

  return [
    HEADER,
    '',
    "import { Module } from '@nestjs/common';",
    "import { TypeOrmModule } from '@nestjs/typeorm';",
    `import { ${repositoryPortName} } from '${relativeImport(context.relationalModuleFile, context.repositoryPortFile)}';`,
    `import { ${repositoryAdapterName} } from '${relativeImport(context.relationalModuleFile, context.relationalRepositoryFile)}';`,
    `import { ${entityName} } from '${relativeImport(context.relationalModuleFile, context.relationalEntityFile)}';`,
    '',
    '@Module({',
    `  imports: [TypeOrmModule.forFeature([${entityName}])],`,
    '  providers: [',
    '    {',
    `      provide: ${repositoryPortName},`,
    `      useClass: ${repositoryAdapterName},`,
    '    },',
    '  ],',
    `  exports: [${repositoryPortName}],`,
    '})',
    `export class ${moduleClassName} {}`,
    '',
  ].join('\n');
}

function renderDomainProperty(field: DMMF.Field, typeInfo: TypeInfo): string[] {
  const propertyName = camelCase(field.name);
  const optional = !field.isRequired;
  const decorator = optional ? 'ApiPropertyOptional' : 'ApiProperty';
  return [`@${decorator}()`, `${propertyName}${optional ? '?' : '!'}: ${buildTsType(typeInfo)};`];
}

function renderRelationProperty(relation: RelationMetadata): string[] {
  const propertyName = relation.propertyName;
  const decorator = relation.field.isRequired ? 'ApiProperty' : 'ApiPropertyOptional';
  const targetClassName = relation.targetContext?.className ?? singularize(pascalCase(relation.targetModel));
  const isArray = relation.field.isList;
  const propertyType = isArray ? `${targetClassName}[]` : `${targetClassName} | null`;
  const decoratorArgs = isArray ? `{ type: () => ${targetClassName}, isArray: true }` : `{ type: () => ${targetClassName} }`;
  const propertyToken = relation.field.isRequired ? '!' : '?';
  return [`@${decorator}(${decoratorArgs})`, `${propertyName}${propertyToken}: ${propertyType};`];
}

function buildRelationToDomainExpression(context: ModuleContext, relation: RelationMetadata): string {
  const propertyAccess = `entity.${relation.propertyName}`;
  if (!relation.targetContext) {
    return relation.field.isList ? `${propertyAccess} ?? []` : `${propertyAccess} ?? null`;
  }
  const mapperName = relation.targetContext === context ? `${context.className}Mapper` : `${relation.targetContext.className}Mapper`;
  if (relation.field.isList) {
    return `${propertyAccess}?.map((item) => ${mapperName}.toDomain(item)) ?? []`;
  }
  return `${propertyAccess} ? ${mapperName}.toDomain(${propertyAccess}) : null`;
}

function buildRelationToEntityAssignmentLines(context: ModuleContext, relation: RelationMetadata): string[] {
  const entityAccess = `entity.${relation.propertyName}`;
  const domainAccess = `domain.${relation.propertyName}`;
  if (!relation.targetContext) {
    return [
      relation.field.isList
        ? `${entityAccess} = ${domainAccess} ?? [];`
        : `${entityAccess} = ${domainAccess} ?? null;`,
    ];
  }
  const mapperName = relation.targetContext === context ? `${context.className}Mapper` : `${relation.targetContext.className}Mapper`;
  if (relation.field.isList) {
    return [`${entityAccess} = ${domainAccess}?.map((item) => ${mapperName}.toEntity(item)) ?? [];`];
  }

  const lines: string[] = [`if (${domainAccess}) {`, `  ${entityAccess} = ${mapperName}.toEntity(${domainAccess});`];
  if (!relation.field.isRequired) {
    lines.push('} else {');
    lines.push(`  ${entityAccess} = null;`);
  }
  lines.push('}');
  return lines;
}

function ensureIdField(context: ModuleContext): DMMF.Field {
  if (!context.idField) {
    throw new Error(`[hex-generator] Model "${context.model.name}" does not define an id field.`);
  }
  return context.idField;
}

function getIdentifierPropertyName(context: ModuleContext): string {
  return camelCase(ensureIdField(context).name);
}

function renderDtoProperty(field: DMMF.Field, optionalOverride: boolean): DtoPropertyRenderResult {
  const propertyName = camelCase(field.name);
  const optional = optionalOverride;
  const decorator = optional ? 'ApiPropertyOptional' : 'ApiProperty';
  const typeInfo = getTypeInfo(field);
  const tsType = buildTsType(typeInfo);
  const validation = renderValidationDecorators(field, optional);
  const lines = [`@${decorator}()`, ...validation.decorators, `${propertyName}${optional ? '?' : '!'}: ${tsType};`];
  return {
    lines,
    usesOptionalDecorator: optional,
    validatorImports: validation.validatorImports,
    needsTransformer: validation.needsTransformer,
    enumImports: validation.enumImports,
  };
}

function renderValidationDecorators(field: DMMF.Field, optional: boolean): ValidationRenderResult {
  const decorators: string[] = [];
  const validatorImports = new Set<string>();
  const enumImports = new Set<string>();
  let needsTransformer = false;

  if (optional) {
    decorators.push('@IsOptional()');
    validatorImports.add('IsOptional');
  }

  if (field.isList) {
    decorators.push('@IsArray()');
    validatorImports.add('IsArray');
  }

  if (field.kind === 'enum') {
    decorators.push(`@IsEnum(${field.type}${field.isList ? ', { each: true }' : ''})`);
    validatorImports.add('IsEnum');
    enumImports.add(field.type);
    return { decorators, validatorImports, needsTransformer, enumImports };
  }

  switch (field.type) {
    case 'String':
    case 'BigInt':
    case 'Bytes':
    case 'Decimal':
      decorators.push(`@IsString(${field.isList ? '{ each: true }' : ''})`.trim());
      validatorImports.add('IsString');
      break;
    case 'Int':
      decorators.push(`@IsInt(${field.isList ? '{ each: true }' : ''})`.trim());
      validatorImports.add('IsInt');
      break;
    case 'Float':
      decorators.push(
        `@IsNumber(${field.isList ? '{ allowInfinity: false, allowNaN: false, maxDecimalPlaces: 2, each: true }' : ''})`.trim(),
      );
      validatorImports.add('IsNumber');
      break;
    case 'Boolean':
      decorators.push(`@IsBoolean(${field.isList ? '{ each: true }' : ''})`.trim());
      validatorImports.add('IsBoolean');
      break;
    case 'Date':
    case 'DateTime':
      decorators.push(`@IsDate(${field.isList ? '{ each: true }' : ''})`.trim());
      validatorImports.add('IsDate');
      needsTransformer = true;
      decorators.push('@Type(() => Date)');
      break;
    case 'Json':
      decorators.push('@IsObject()');
      validatorImports.add('IsObject');
      break;
    default:
      decorators.push(`@IsString(${field.isList ? '{ each: true }' : ''})`.trim());
      validatorImports.add('IsString');
  }

  return { decorators, validatorImports, needsTransformer, enumImports };
}

function getScalarFields(model: DMMF.Model): DMMF.Field[] {
  return model.fields.filter((field) => field.kind !== 'object');
}

function getRelationFields(model: DMMF.Model): DMMF.Field[] {
  return model.fields.filter((field) => field.kind === 'object');
}

function attachRelationMetadata(contexts: ModuleContext[], contextByModelName: Map<string, ModuleContext>) {
  contexts.forEach((context) => {
    context.relations = context.relationFields
      .filter((field) => Array.isArray(field.relationFromFields) && field.relationFromFields.length > 0)
      .map((field) => ({
        field,
        propertyName: camelCase(field.name),
        targetModel: field.type,
        targetContext: contextByModelName.get(field.type),
      }));
  });
}

function isWritableField(field: DMMF.Field): boolean {
  if (field.isId) {
    return false;
  }
  return !READ_ONLY_FIELDS.has(field.name) && !READ_ONLY_FIELDS.has(camelCase(field.name));
}

function determineCreateOptional(field: DMMF.Field): boolean {
  if (!field.isRequired) {
    return true;
  }
  return field.hasDefaultValue;
}

interface TypeInfo {
  baseType: string;
  isArray: boolean;
  isNullable: boolean;
  enumType?: string;
}

function getTypeInfo(field: DMMF.Field): TypeInfo {
  let baseType: string;
  let enumType: string | undefined;
  if (field.kind === 'enum') {
    baseType = field.type;
    enumType = field.type;
  } else {
    switch (field.type) {
      case 'Int':
      case 'Float':
        baseType = 'number';
        break;
      case 'BigInt':
      case 'Decimal':
        baseType = 'string';
        break;
      case 'Date':
      case 'DateTime':
        baseType = 'Date';
        break;
      case 'Boolean':
        baseType = 'boolean';
        break;
      case 'Json':
        baseType = 'Record<string, unknown>';
        break;
      case 'Bytes':
        baseType = 'Buffer';
        break;
      default:
        baseType = 'string';
    }
  }

  return {
    baseType,
    isArray: field.isList,
    isNullable: !field.isRequired,
    enumType,
  };
}

function buildTsType(info: TypeInfo): string {
  let type = info.baseType;
  if (info.isArray) {
    type = `${type}[]`;
  }
  if (info.isNullable) {
    type = `${type} | null`;
  }
  return type;
}

function getCreateDataType(context: ModuleContext): string {
  const omitFields = context.scalarFields
    .filter((field) => !isWritableField(field))
    .map((field) => `'${camelCase(field.name)}'`);
  if (omitFields.length) {
    return `Omit<${context.className}, ${omitFields.join(' | ')}>`;
  }
  return context.className;
}

function getEntityAliasName(context: ModuleContext): string {
  return `${context.className}Entity`;
}

function pluralize(value: string): string {
  return pluralizeLib(value);
}

function relativeImport(fromFile: string, toFile: string): string {
  const relativePath = path.relative(path.dirname(fromFile), toFile).replace(/\\/g, '/').replace(/\.ts$/, '');
  return relativePath.startsWith('.') ? relativePath : `./${relativePath}`;
}

function singularize(value: string): string {
  return pluralizeLib.singular(value);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});




